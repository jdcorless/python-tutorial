#+TITLE: Notes from the Python 3.4.2 Tutorial
#+AUTHOR: John D. Corless
#+OPTIONS: html-link-use-abs-url:nil html-postamble:auto
#+OPTIONS: html-preamble:t html-scripts:t html-style:t
#+OPTIONS: html5-fancy:nil tex:t
#+CREATOR: <a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.4.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)
#+HTML_CONTAINER: div
#+HTML_DOCTYPE: xhtml-strict
#+INFOJS_OPT: view:t toc:t ltoc:t mouse:underline buttons:0 path:http://thomasf.github.io/solarized-css/org-info.min.js
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://thomasf.github.io/solarized-css/solarized-light.min.css" />
#+HTML_HEAD_EXTRA:
#+HTML_LINK_HOME:
#+HTML_LINK_UP:
#+HTML_MATHJAX:
#+LATEX_HEADER:

These are my notes from the official Python tutorial for version 3.4.2.
They are not intended to be complete, because the tutorial is readily [[https://docs.python.org/3.4/tutorial/][available]], but it helps my memory to write this down and serves as a more personal reference for me.
A couple things to note...

- In many instances I have copied sentences and examples directly from the tutorial
- The org-mode notes have some extra information that I chose not to export

** Whetting Your Appetite
Describes advantages of Python for various applications.
The following shows that we are using Python 3.4.2.
#+BEGIN_SRC python :results output :exports both
import sys
print(sys.version)
#+END_SRC

#+RESULTS:
: 3.4.2 |Continuum Analytics, Inc.| (default, Oct 21 2014, 17:40:08) 
: [GCC 4.4.7 20120313 (Red Hat 4.4.7-1)]

** Using the Python Interpreter
From the module =sys=, the =sys.argv= variable carries info passed when the python command was invoked.
The zeroth argument has different values depending on how it was called.
#+BEGIN_SRC python :results output :exports none
import sys
for c,i in enumerate(sys.argv):
    print(c,i)
#+END_SRC

#+RESULTS:
: (0, '')

Continuation lines show up as =...= in the interactive shell.
Here is the example used but without this symbol because we are in Emacs.
#+BEGIN_SRC python :results output :exports none
the_world_is_flat = True
if the_world_is_flat:
    print("Be careful not to fall off!")
#+END_SRC

#+RESULTS:
: Be careful not to fall off!

By default, Python source code files are treated as UTF-8.
To use something other than this default, put a comment such as the following at the top of the script file (1st or 2nd line allowed) =# -*- coding: cp-1252 -*-=.

** An Informal Introduction to Python
Python comments begin with a =#=, such that all input on the line after this mark are ignored.
Division in Python3 always returns a float (not true of Python2).
*Floor Division* (discard the fractional part) with the =//= operation.
Raise a number to a power with =**= operator (and note that =**= has higher precendence than =-= so =-3**2= evaluates to =-9=).
Assignment operator is ===.
#+BEGIN_SRC python :results output :exports both
print('Example of integer math is 2+2 = ', 2+2)
print('Example of Python3 division is 8/5 =', 8/5)
print('Integer part of 8/5 is', 8//5) # Here is // operator
print('Remainder of 8/5 is', 8 % 5)
print('Fractional part of 8/5 is', (8%5)/5)
print('2 to the 3 power is', 2**3)
#+END_SRC

#+RESULTS:
: Example of integer math is 2+2 =  4
: Example of Python3 division is 8/5 = 1.6
: Integer part of 8/5 is 1
: Remainder of 8/5 is 3
: Fractional part of 8/5 is 0.6
: 2 to the 3 power is 8

In interactive mode, the last printed expression is assigned to the variable =_=.
In addition to int and float, Python supports other types of numbers, such as Decimal and Fraction.
-------
The *Decimal* type is an implementation of "fast correctly-rounded floating point arithmetic".
Some references are the [[http://speleotrove.com/decimal/decarith.html][IBM's General Decimal Arithmetic Specification]] and the [[http://754r.ucbtest.org/standards/854.pdf][IEEE standard 854-1987]].
I haven't researched this too much, but here is an illustrative example.
#+BEGIN_SRC python :results output :exports both
from decimal import *
a = 1.1+2.2 # standard float math
b = Decimal(1.1) + Decimal(2.2) # Conv from float is exact val of float
c = Decimal('1.1') + Decimal('2.2') # Conversion from str is that val
print('getcontext() =', getcontext())
print('Standard precision of Decimal module =',getcontext().prec)
print('Now look at 1.1 + 2.2 in a few different methods')
print('Result of float math =',a)
print('Result of Decimal conv of float =',b)
print('Result of Decimal conv of str =',c)
#+END_SRC

#+RESULTS:
: getcontext() = Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999, capitals=1, clamp=0, flags=[Inexact, FloatOperation, Rounded], traps=[InvalidOperation, DivisionByZero, Overflow])
: Standard precision of Decimal module = 28
: Now look at 1.1 + 2.2 in a few different methods
: Result of float math = 3.3000000000000003
: Result of Decimal conv of float = 3.300000000000000266453525910
: Result of Decimal conv of str = 3.3

-------
The *Fraction* type provides for rational number arithmetic.
#+BEGIN_SRC python :results output :exports both
from fractions import Fraction
print(Fraction(1,5)*Fraction(2,7))
print(Fraction(16, -10))
from decimal import Decimal
print(Fraction(Decimal('1.1')))
#+END_SRC

#+RESULTS:
: 2/35
: -8/5
: 11/10

Python also has built-in support for complex numbers, and uses the j or J suffix to indicate the imaginary part (e.g. 3+5j).
-------
*Strings* can be enclosed in single =​'​= or double =​"​= quotes with the same result.
The symbol =\= can be used to escape quote symbols (or other special characters).
The control character =\n= is used for new lines as in =​'First line.\nSecond line.'​=.
If you don't want characters prefaced by =\= to be interpreted as special characters you can use /raw strings/ by adding the =r= before the first quote, as in...
#+BEGIN_SRC python :results output :exports both
print('C:\some\name')
print('<-----######----->')
print(r'C:\some\name')
#+END_SRC

#+RESULTS:
: C:\some
: ame
: <-----######----->
: C:\some\name

String literals can span multiple lines with triple quotes, single =​'​= or double =​"​=. End of lines are automatically included unless the =\= character is used to indicate line continuation.
#+BEGIN_SRC python :results output :exports both
print('''\
Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to
''')
#+END_SRC

#+RESULTS:
: Usage: thingy [OPTIONS]
:      -h                        Display this usage message
:      -H hostname               Hostname to connect to
: 

Strings can be concatenated with the =*= and =+= operator, or just with a space (only works with literals, and is useful for breaking long strings).
#+BEGIN_SRC python :results output :exports both
print(3*'Ho, ' + 'Green Giant!')
print('Hi' 'Ho!')
text = ('Four score and seven years ago, '
        'our fathers brought forth ... a new nation')
print(text)
#+END_SRC

#+RESULTS:
: Ho, Ho, Ho, Green Giant!
: HiHo!
: Four score and seven years ago, our fathers brought forth ... a new nation

Strings can be indexed with the first character having index 0.
There is no character type (i.e. a character is a string of size one).
Ranges can be specified as =[n:m]= where the =nth= element is always included and the =mth= is always excluded.
This makes sure that =s[:i] + s[i:]= always equals =s=.
If the 1st index is omitted it defaults to zero and if the 2nd index is omitted it defaults to the size of the string being sliced.
#+BEGIN_SRC python :results output :exports both
word = 'Python'
print('1. String is \'' + word + '\'')
print('2. First character is', word[0])
print('3. Sixth character is', word[5])
print('4. Last character is', word[-1])
print('5. Second-to-last character is', word[-2])
print('6. Second through fourth characters are', word[1:4])
print('7. ' + word[:2] + word[2:])
#+END_SRC

#+RESULTS:
: 1. String is 'Python'
: 2. First character is P
: 3. Sixth character is n
: 4. Last character is n
: 5. Second-to-last character is o
: 6. Second through fourth characters are yth
: 7. Python

One way to understand slicing is to think of the indices pointing in /between/ characters.
The =i:j= slice consists of characters between the edges labelled =i= and =j=.
#+BEGIN_EXAMPLE
 +---+---+---+---+---+---+
 | P | y | t | h | o | n |
 +---+---+---+---+---+---+
 0   1   2   3   4   5   6
-6  -5  -4  -3  -2  -1
#+END_EXAMPLE
Python strings cannot be changed, they are *immutable*. So, for instance, =​word[0] = 'a'​= will not work. 
=len()= returns the length of a string (and lists).
[[https://docs.python.org/3.4/library/stdtypes.html#string-methods][/String methods/]] are available, for example, as =word.lower()=, or =word.capitalize()=.
The =printf()= style formatting is [[https://docs.python.org/3.4/library/stdtypes.html#old-string-formatting][available]] but can lead to errors, e.g. with tuples.
The newer [[https://docs.python.org/3.4/library/stdtypes.html#str.format][=str.format()=]] method avoids these errors and provides a more powerful approach.

-------

Python has several compound data types, perhaps the most versatile being *Lists*, which are written as comma separated values.  Like strings (and all other built-in sequence types), lists can be indexed and sliced.
Lists are also mutable, and so can be modified.

#+BEGIN_SRC python :results output :exports both
squares = [1, 4, 9, 24]
print('Squares with error =', squares)
squares[3] = 25    # Lists are mutable
print('Corrected squares  =', squares)
squares.append(36) # Append a value to list
print('Appended squares   =', squares)
squares[1:3] = ['aa', 'bb']
print('Slice assgined     =',squares)
#+END_SRC

#+RESULTS:
: Squares with error = [1, 4, 9, 24]
: Corrected squares  = [1, 4, 9, 25]
: Appended squares   = [1, 4, 9, 25, 36]
: Slide assgined     = [1, 'aa', 'bb', 25, 36]

Lists can also be nested to create lists of lists. 
-------
*First Steps Towards Programming*
At this point the tutorial gives a simple example for computing the Fibonacci sequence that highlights some elements of Python programming.
#+BEGIN_SRC python :results output :exports both
# Fibonacci series:
# the sum of two elements defines the next
a, b = 0, 1
while b < 10:
    print(b,end=', ')
    a, b = b, a+b
#+END_SRC

#+RESULTS:
: 1, 1, 2, 3, 5, 8, 

- /Multiple assignment/ is shown where multiple variables simultaneously are assigned new values. The right-hand side is evaluated first (from left-to-right) and then assignment takes place.
- The =while= loops executes as long as the condition is true.  Like =C=, any non-zero integer value is true, zero is false.  A string, list, or any sequence can be used and will evaluate to True unless it is of zero length. The standard comparison operators (=<=, =>=, =<=​=, =>=​=, =​==​=, and =!=​=).
- The /body/ of the =while= loop is indented, which is Python's way of grouping statements.  Each line in a basic block must be identically indented.
- 
** More Control Flow Tools
Perhaps the most well known statement is the *if* statement.
There can be zero or more =elif= parts and the =else= is optional.
The =if...elif...elif= construct is a substitute for =case= and =switch= in other languages.
#+BEGIN_SRC python :results output :exports both
#x = int(input("Please enter an integer: "))
x = -1
if x < 0:
    x = 0
    print('Negative changed to zero')
elif x == 0:
    print('Zero')
elif x == 1:
    print('Single')
else:
    print('More')
#+END_SRC

#+RESULTS:
: Negative changed to zero

Note that the above illustrates that at most one of the group of
statements is executed.
When the =if= is entered =x= is =-1=, and while
its value is changed to =0= the flow does not enter the =​x=0​= group.
-------
The *for* statement in Python is somewhat different than other languages in that Python allows the user to iterate over the items of any sequence.

#+BEGIN_SRC python :results output :exports both
# Measure some strings:
words = ['cat', 'window', 'defenestrate']
for w in words:
    print(w, len(w), end=', ')
#+END_SRC

#+RESULTS:
: cat 3, window 6, defenestrate 12, 

If you need to change an item in a sequence that you are iterating over, it is recommended that you iterate over a copy, which can be done with the simple =[:]= notation.
#+BEGIN_SRC python :results output :exports both
words = ['cat', 'window', 'defenestrate']
for w in words[:]:
    if len(w) > 6:
        words.insert(0, w)
print(words)
#+END_SRC

#+RESULTS:
: ['defenestrate', 'cat', 'window', 'defenestrate']

Note that the =list.insert(idx,item)= inserts =item= into =list= before index =idx=.

Alternatively you can iterate using the =range= function if you need to iterate over a sequence of numbers (=for i in range(7)= as an example).
Note that =range(7)= generates 7 values from 0 to 6 (which are the legal indices for a sequence of length 7).
And =range(5,10)= will create a list from 5 to 9, while =range(0,10,3)= will have the range start at 0 and go up to 9 (max) in steps of 3.
The =range= function creates an object of type =range= which is not a list (to save space) but returns successive items in the sequence when you iterate over it.
We say that such an object is an /iterable/ which can be used by /iterators/ like the =for= statement.
The [[https://docs.python.org/3.4/library/functions.html#enumerate][enumerate]] function allows looping over a sequence while also creating an index over that sequence.

-------
The =break= statement breaks out of the smallest enclosing =for= or =while= loop.
Loop statements may have an =else= clause that is executed when the loop terminates through exhaustion of the list (=for=) or when the condition becomes false (=while=), but not when looping is terminated with a =break=.
In the code below, the =break= statement breaks out of the enclosing =for= loop when =n= is divisible by =x= (i.e. not prime), and the =else= statement is executed if the =for= loop exhausts its iterable.

#+BEGIN_SRC python :results output :exports both
for n in range(2, 10):
    for x in range(2, n):
        if n % x == 0:
            print(n, 'equals', x, '*', n//x)
            break
    else:
        # loop fell through without finding a factor
        print(n, 'is a prime number')
#+END_SRC

#+RESULTS:
: 2 is a prime number
: 3 is a prime number
: 4 equals 2 * 2
: 5 is a prime number
: 6 equals 2 * 3
: 7 is a prime number
: 8 equals 2 * 4
: 9 equals 3 * 3

When used with a =for= or =while= loop, the =else= clause has more in common with the =else= clause of a =try= statement which runs when control flows off the end of the =try= (except in the case of an exception, =return=, =continue=, or =break=).
-------
The =pass= statement does nothing, but can be used when a statement is required syntatically but the program requires no action.
An example is in creating minimal classes, or as a reminder to implement some code later.
#+BEGIN_SRC python
class MyEmptyClass:
    pass
def initlog(*args):
    pass # Remember to implement this!
#+END_SRC

#+RESULTS:
: None
-------
We use the keyword =def= in *Defining Functions*.
It must be followed by the function name and the parenthesized list of formal parameters.
The function body follows and is indented.
And here is an example function we will use.
#+BEGIN_SRC python :results output :exports both
def fib(n):    # write Fibonacci series up to n
    """Print a Fibonacci series up to n."""
    a, b = 0, 1
    while a < n:
        print(a, end=' ')
        a, b = b, a+b
    print()

# Now call the function we just defined:
fib(2000)
#+END_SRC

#+RESULTS:
: 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 

The execution of a function introduces a new symbol table used for local variables of the function.
Variable references first look in local symbol table, then local symbol tables of enclosing functions, then global symbol table, and finally in table of built-in names (sometimes called the LEGB rule for Local, Enclosing, Global, and Built-in).
The function arguments are introduced to the local symbol table when the function is called.
Arguments are passed by object reference, so if the object is mutable (e.g. dictionaries, lists) it is subject to change by the function, but if it is immutable (e.g. numbers, strings, tuples) it will not change.

#+BEGIN_SRC python :results output :exports both
a = 1 # ints are immutable
def f(x):
    x = 10
f(a)
print(a) # did not change
a = [1,2] # lists are mutable
def f(x):
    x.append('New')
f(a)
print(a) # Changed
#+END_SRC

#+RESULTS:
: 1
: [1, 2, 'New']

From the [[https://docs.python.org/3.4/reference/datamodel.html][Data Model]] reference, /objects/ in Python are abstractions for data.
Every object has an identity (think of like an address in memory), a type, and a value.

#+BEGIN_SRC python :results output :exports both
a = 10
print('identity =',id(a),', type =',type(a),', and value =',a)
a = (1,2,3)
print('identity =',id(a),', type =',type(a),', and value =',a)
#+END_SRC

#+RESULTS:
: identity = 3077931696 , type = <class 'int'> , and value = 10
: identity = 3070469140 , type = <class 'tuple'> , and value = (1, 2, 3)

A function definition introduces the function name into the current symbol table.
The function can be assigned to a new name with =fnew=f=.
The =return= statement returns a value from a function.
Functions that don't explicitly return a value still return the Python special value =None=.
A =method= is a function that belongs to an object and is called with dot notation, as in =obj.methodname()=.
It is possible to define your own objects and methods using classes.
-------
Here we review *More on Defining Functions*.
There are three forms that can be used to define functions with a variable number of arguments.
*** Default Argument Values
The most useful is to specify a default value for one or more arguments.
This creates a function that can be called with fewer arguments than it is defined to allow.
#+BEGIN_SRC python :results output :exports both
def calc(op, x=4, y=5):
    if op == '*':
        print(x*y)
    elif op == '+':
        print(x+y)
    elif op == '-':
        print(x-y)
    else:
        print(x/y)
# Can be called in one of three ways
calc('*')        # giving only the mandatory argument
calc('+', 1)     # giving one of the optional arguments
calc('/', 25, 5) # giving all the arguments
#+END_SRC

#+RESULTS:
: 20
: 6
: 5.0

Note that the default values are evaluated at the point of function definition in the /defining/ scope.
#+BEGIN_SRC python :results output :exports both
i = 5
def f(arg=i):
    print(arg)
i = 6
f() # returns value determined from defining scope
#+END_SRC

#+RESULTS:
: 5

And also worth noting is that the default is only evaluated /once/, so if it is a mutable quantity it could change over subsequent calls, as shown in the example below.
#+BEGIN_SRC python :results output :exports both
def f(a, L=[]):
    L.append(a)
    return L
print(f(1)) # L starts as empty and gets 1 added
print(f(2)) # L already has 1, and 2 gets added
print(f(3)) # And now 3 gets added
#+END_SRC

#+RESULTS:
: [1]
: [1, 2]
: [1, 2, 3]

If you don't want the default value to be shared between calls, here is a solution (FIXME I can't really follow why this works).

#+BEGIN_SRC python :results output :exports both
def f(a, L=None):
    if L is None:
        L = []
    L.append(a)
    return L
print(f(1))
print(f(2))
print(f(3))
#+END_SRC

#+RESULTS:
: [1]
: [2]
: [3]

*** Keyword Arguments
Functions can also be called with /keyword arguments/ of the form =kwarg=value=.
This approach is very similar to the default argument case above except that the keyword is explicitly given.
In a function call, keyword arguments must follow positional arguments, all keywords must match those given in the function definition, and their order does not matter.
When a final formal parameter of the form =**name= is present, it receives a dictionary containing all keyword arguments (except those corresponding to a formal parameter).
Formal parameters of the form =*name= receive a tuple containing the positional arguments beyond the formal parameter list (=*name= must occur before =**name=).
#+BEGIN_SRC python :results output :exports both
def cheeseshop(kind, *arguments, **keywords):
    print("-- Do you have any", kind, "?")
    print("-- I'm sorry, we're all out of", kind)
    for arg in arguments:
        print(arg)
    print("-" * 40)
    keys = sorted(keywords.keys())
    for kw in keys:
        print(kw, ":", keywords[kw])
# Call function
cheeseshop("Limburger", "It's very runny, sir.",
           "It's really very, VERY runny, sir.",
           shopkeeper="Michael Palin",
           client="John Cleese",
           sketch="Cheese Shop Sketch")
#+END_SRC

#+RESULTS:
: -- Do you have any Limburger ?
: -- I'm sorry, we're all out of Limburger
: It's very runny, sir.
: It's really very, VERY runny, sir.
: ----------------------------------------
: client : John Cleese
: shopkeeper : Michael Palin
: sketch : Cheese Shop Sketch

*** Arbitrary Argument Lists
The least frequently used approach is to specify that a function can be called with an arbitary number of arguments.
Before this zero or more normal arguments may occur, and the arbitrary list will be wrapped in a tuple.
If a formal parameter occurs after the =*args= parameter must be keyword-only.
#+BEGIN_SRC python :results output :exports both
def concat(*args, sep="/"):
   print(sep.join(args))
concat("earth", "mars", "venus")
concat("earth", "mars", "venus", sep=".")
#+END_SRC

#+RESULTS:
: earth/mars/venus
: earth.mars.venus

*** Unpacking Argument Lists
When arguments are already in a list or tuple but need to be unpacked for a function call, the operator =*= can be used during the function call to unpack out the arguments.
In the same way, dictionaries can be unpacked with the =**= operator.
So =*= and =**= can be used in function definitions to accept tuples and dictionaries, or used on function calls to pass tuples or dictionaries to functions that otherwise did not allow for their use.
Below is a simple example demonstrating this difference, and it appears to me that it is more flexible to use =*args= in the function definition because then you can write the code for an arbitrary number of parameters (if that is needed) whereas the other approach does not seem to allow that because the unpacking results in a fixed number of parameter and the code must know how to handle them.
Finally, note that the tutorial says that =*name= receives a tuple, but really it is passed as =x1,x2,x3= and not as =(x1,x2,x3)=.
#+BEGIN_SRC python :results output :exports both
def f1(x, *args):
    sum = x
    for i in args:
    	sum += i
    return sum
print('Result from function with *args definition =',f1(1,2,3,4))
def f2(x1, x2, x3, x4):
    return x1 + x2 + x3 + x4
arg = [2,3,4]
print('Result from unpacking arguments with *args =',f2(1,*arg))
#+END_SRC

#+RESULTS:
: Result from function with *args definition = 10
: Result from unpacking arguments with *args = 10

*** Lambda Expressions
The =lambda= keyword allows for small (single expression), anonymous functions.
They are /syntatic sugar/ for a normal function definition.
One use is to pass a small function as an argument.
#+BEGIN_SRC python :results output :exports both
pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]
pairs.sort(key=lambda x: x[1])
print(pairs)
#+END_SRC

#+RESULTS:
: [(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]

*** Documentation Strings
The first statement in the function body can optionally be a string literal, which serves as the function's [[https://docs.python.org/3.4/tutorial/controlflow.html#tut-docstrings][documentation string]] or /docstring/.
- First line should be short, concise summary, starting with a capital letter, ending with a period, and not using function name.
- If more than one line, 2nd line is blank to visually separate.
- This second section should be one or more paragraphs describing calling conventions, side effects, etc.
- The Python parser does not strip indentation from multi-line string literals
- The following shows the convention for indentation.
#+BEGIN_SRC python :results output :exports both
def my_function():
    """Do nothing, but document it.

    No, really, it doesn't do anything.
    """
    pass
print(my_function.__doc__)
#+END_SRC

#+RESULTS:
: Do nothing, but document it.
: 
:     No, really, it doesn't do anything.

*** Function Annotations
Function annotations are optional, arbitrary metadata about user-defined functions.
Annotations are stored in the =__annotations__= attribute of a function as a dictionary.
*** Coding Style
Pythonic *coding style* is described in [[http://www.python.org/dev/peps/pep-0008][PEP 8]].
It promotes a readable and eye-pleasing coding style, including these important points.

- Use 4-space indentation, and no tabs.
- Wrap lines so that they don’t exceed 79 characters.
- Use blank lines to separate functions and classes, and larger blocks of code inside functions.
- When possible, put comments on a line of their own.
- Use docstrings.
- Use spaces around operators and after commas, but not directly inside bracketing constructs: a = f(1, 2) + g(3, 4).
- Name your classes and functions consistently; the convention is to use CamelCase for classes and lower_case_with_underscores for functions and methods. Always use self as the name for the first method argument (see A First Look at Classes for more on classes and methods).
- Don’t use fancy encodings if your code is meant to be used in international environments. Python’s default, UTF-8, or even plain ASCII works best in any case.
- Likewise, don’t use non-ASCII characters in identifiers if there is only the slightest chance people speaking a different language will read or maintain the code.

** Data Structures
*** More on Lists
Here are all the methods of list objects.
- =list.append(x)= :: add item to end of list
- =list.extend(L)= :: add list =L= to end of list
- =list.insert(i, x)= :: insert an item =x= at a given position =i=
- =list.remove(x)= :: remove the first item from this list that matches =x=
- =list.pop([i])= :: remove the item at the given position, and return it (last item if no index given). Note that the square bracket notation means that the index is optional (not to type square brackets), and this notation appears throughout Python documentation.
- =list.clear()= :: remove all items from list leaving the empty list =[]= (equivalent to =del a[:]=)
- =list.index(x)= :: return the index of the first item whose value is =x=
- =list.count(x)= :: return the number of times =x= appears in list
- =list.sort()= :: sort the items of the list in place
- =list.reverse()= :: reverse the items of list in place
- =list.copy()= :: return a shallow copy of the list (equivalent to =a[:]=)

Lists can be used like a stack where the =pop= method with no index returns the last item added (with, for example, the =append= method), like "last-in, first-out".
A "first-in, first-out" queue can be done also, but is much slower, and the =collections.deque= is recommended instead for this application.
#+BEGIN_SRC python :results output :exports both
from collections import deque
queue = deque(["Eric", "John", "Michael"])
queue.append("Terry")           # Terry arrives
queue.append("Graham")          # Graham arrives
print(queue.popleft())          # The first to arrive now leaves
print(queue.popleft())          # The second to arrive now leaves
print(queue)                    # Remaining queue in order of arrival
#+END_SRC

#+RESULTS:
: Eric
: John
: deque(['Michael', 'Terry', 'Graham'])

*List comprehensions* are a concise way to create lists, often used when a new list is needed from the operation on each element of another sequence or iterable.
They consist of brackets containing an expression followed by a =for= clause, then zero or more =for= or =if= clauses.
The result is a new list resulting from evaluating expression in the context of the =for= and =if= clauses which follow it.
Here is an example that creates =(x,y)= tuples over separate =x= and =y= lists where =x= is not equal to =y=.
#+BEGIN_SRC python :results output :exports both
print([(x, y) for x in [1,2,3] for y in [3,1,4] if x != y])
#+END_SRC

#+RESULTS:
: [(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
They can also be nested, as in this example to transpose a matrix (only using numpy to make the =print= command give more matrix-like results).
#+BEGIN_SRC python :results output :exports both
from numpy import array
matrix = array([
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12],
])
print(array([[row[i] for row in matrix] for i in range(4)]))
#+END_SRC

#+RESULTS:
: [[ 1  5  9]
:  [ 2  6 10]
:  [ 3  7 11]
:  [ 4  8 12]]
: [(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]

A built-in function should be preferred over complex flow statements, and the same transpose can be accomplished with =list(zip(*matrix))=.

*** The =del= Statement
The =del= command allows removal of an item (or slice of items) from a list based on its index.
The command is =del a[0]= or =del a[1:3]=, and =del a[:]= would make =a= an empty list, and =del a= would completely delete the variable.
*** Tuples and Sequences
There are three basic [[https://docs.python.org/3.4/library/stdtypes.html#typesseq][Sequence Types]], the list, range, and tuple.
The tuple consists of a number of values separated by commas.
Tuples are always enclosed in parentheses on output, but need not on input.
Tuples are
- Immutable
- Usually contain heterogeneous elements
- Accessed via unpacking or indexing (or by attribute in =namedtuples=)
On the other hand, Lists are mutable, usually homogeneous elements, and are accessed by iterating over list.
#+BEGIN_SRC python :results output :exports both
t = 12345, 54321, 'hello!'
print('t[0] =', t[0], ', and t =', t)
# Tuples may be nested:
u = t, (1, 2, 3, 4, 5); print(u)
# Tuples are immutable, so t[0] = 88888 will not work
# but they can contain mutable objects:
v = ([1, 2, 3], [3, 2, 1]); print(v)
#+END_SRC

#+RESULTS:
: t[0] = 12345 , and t = (12345, 54321, 'hello!')
: ((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))
: ([1, 2, 3], [3, 2, 1])

An empty tuple is created as =()= and one with a single element (usually referred to as a singleton) must have a trailing comma, like =singleton​=​'hello',​=.
An example of tuple packing is =t = 1, 'a', 12345= and to unpack the tuple would be =x,y,z=t=.
*** Sets
A *set* is an unordered collection with no duplicate elements.
They support operations like union, intersection, difference, and symmetric difference.
Curly braces or the =set()= function can be used to create sets.
To create an empty set use =set()= because ={}= creates an empty dictionary.
#+BEGIN_SRC python :results output :exports both
basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
print(basket)                      # show that duplicates have been removed
print('orange' in basket)          # fast membership testing
print('crabgrass' in basket)
# Demonstrate set operations on unique letters from two words
a = set('abracadabra'); print('a =',a) # unique letters in a
b = set('alacazam'); print('b =',b)    # unique letters in a
print('a - b =', a - b)                # letters in a but not in b
print('a | b =', a | b)                # letters in either a or b
print('a & b =', a & b)                # letters in both a and b
print('a ^ b =',a ^ b)                 # letters in a or b but not both
#+END_SRC

#+RESULTS:
: {'pear', 'orange', 'banana', 'apple'}
: True
: False
: a = {'c', 'a', 'b', 'd', 'r'}
: b = {'c', 'a', 'm', 'l', 'z'}
: a - b = {'r', 'b', 'd'}
: a | b = {'m', 'l', 'c', 'b', 'd', 'a', 'z', 'r'}
: a & b = {'c', 'a'}
: a ^ b = {'m', 'l', 'b', 'd', 'z', 'r'}

Just like list comprehensions, *set comprehensions* are also supported but use curly braces instead of square brackets.
*** Dictionaries
*Dictionaries* are also known as associative arrays or memories, and are an unordered pair of /key:value/ pairs.
Unlike sequences which are indexed by a range of numbers, dictionaries are indexed by /keys/, which can be any immutable type.
The keys must be unique.
The expression ={}= creates an empty dictionary, and adding comma separate key:value pairs is how to add elements.
=list(d.keys())= gives a list of the keys in the dictionary in arbitrary order, or =sorted(d.keys())= in sorted order.
Here are some syntax options for creating dictionaries.
#+BEGIN_SRC python :results output :exports both
tel = {'jack': 4098, 'sape': 4139}
tel = dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])
tel = {x: x**2 for x in (2, 4, 6)} # dictionary comprehension
tel = dict(sape=4139, guido=4127, jack=4098)
#+END_SRC
*** Looping Techniques
Loop over dictionaries using the =items()= method..
#+BEGIN_SRC python :results output :exports both
knights = {'gallahad': 'the pure', 'robin': 'the brave'}
for k, v in knights.items():
    print(k, v)
#+END_SRC

#+RESULTS:
: robin the brave
: gallahad the pure

Can loop over sequences getting both the index and value with the =enumerate= function.
#+BEGIN_SRC python :results output :exports both
for i, v in enumerate(['tic', 'tac', 'toe']):
    print(i, v)
#+END_SRC

#+RESULTS:
: 0 tic
: 1 tac
: 2 toe

To loop over two or more sequences at the same time, the entries can be paried with the =zip()= function.
#+BEGIN_SRC python :results output :exports both
questions = ['name', 'quest', 'favorite color']
answers = ['lancelot', 'the holy grail', 'blue']
for q, a in zip(questions, answers):
    print('What is your {0}?  It is {1}.'.format(q, a))
#+END_SRC

#+RESULTS:
: What is your name?  It is lancelot.
: What is your quest?  It is the holy grail.
: What is your favorite color?  It is blue.

You can also reverse the order of a sequence with =reversed()= and loop. The =sorted()= function can be used to sort a sequence before looping to control the order as well (the =set()= function is used first in the example below to remove duplicates).
#+BEGIN_SRC python :results output :exports both
basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
for f in sorted(set(basket)):
    print(f)
#+END_SRC

#+RESULTS:
: apple
: banana
: orange
: pear

And finally, if the sequence you need to loop over may be modified, it is recommended that you first make a copy with, for example =words[:]=.
*** More on Conditions
The operators =in= and =not in= check to see if a value occurs in a sequence.
The operators =is= and =not is= check to see whether two objects are the same.
Comparisons can be chained as in ~a<b==c​~ which tests whether a is less than b and b is equal to c.
Comparisons can be combined with =and= and =or=, and the outcome can be negated with =not=.
=not= has the highest priority and =or= the lowest, so =A and not B or C= is equivalent to =(A and (not B)) or C=.
*** Comparing Sequences and Other Types
Sequence objects of the same type can be compared.
The comparison starts by comparing the first two objects and if they differ this determines the outcome of the comparison.
If they are equal, the next two items are compared, and so on.
This uses so-called /lexicographical/ ordering.
If all items of two sequences are equal, the sequences are equal.
If one sequence is an initial sub-sequence of the other then the shorter one is lesser.
Here are some examples that show the rules in action (all statements are =True=).
#+BEGIN_EXAMPLE
(1, 2, 3)              < (1, 2, 4)
[1, 2, 3]              < [1, 2, 4]
'ABC' < 'C' < 'Pascal' < 'Python'
(1, 2, 3, 4)           < (1, 2, 4)
(1, 2)                 < (1, 2, -1)
(1, 2, 3)             == (1.0, 2.0, 3.0)
(1, 2, ('aa', 'ab'))   < (1, 2, ('abc', 'a'), 4)
#+END_EXAMPLE

** Modules
A *Module* is a file containining Python definitions and statements.
The file name is the module name with the suffix =.py=.
Within the module, the name is available as the global variable =__name__=.
For example, a file =fibo.py= can be imported with =import fibo= which creates a namespace where =fibo.function= accesses =function= within the fibo module.
You can give a function a local name by =fib = fibo.fib=.
Executable statements inside a module are only executed the first time the module is imported.
Each module has its own private symbol table which is used as the global symbol table for all functions in the module (it is possible to access these as =modname.itemname=).

It is customary to put all =import= statements at the beginning of a module.
The variant =from fibo import fib1, fib2= imports names directly into the importing module namespace.
To get all names in the module you can use =from fibo import *= (which imports all names except those beginning with an underscore (=_=).
In general the practice of importing with the =*= is not recommended because it impacts code readability and can clobber items in the existing namespace.

Since each module is loaded only once in an interactive session, if changes to a module need to be tested we need a way to reload.  This is provided by the =importlib= module.
#+BEGIN_EXAMPLE
import importlib
import mylibrary
# changes made to mylibrary
importlib.reload(mylibrary)
#+END_EXAMPLE

When you run a module with =$ python fibo.py <arguments>= the code is executed by the =__name__= variable set to =​"__main__"​=.  So if you add the following code at the end of your module you can make your module (here assumed to contain an algorithm to compute the Fibonacci sequence) usable as a script as well as an importable module.
#+BEGIN_SRC python
if __name__ == "__main__":
    import sys
    fib(int(sys.argv[1]))
#+END_SRC
Then the command =$ python fib.py 50= will return the Fibonacci numbers from the command line.
But if you run =import fib= from with the interpreter, the code in the =​"__main__"​= section will not run.
This approach is often used to run the module for testing so that the =​"__main__"​= section has testing code.

-------
When a module is imported, the interpreter follows the *Module Search Path*.
First the interpreter looks for a built-in module by that name, then it search a list of directories given by =sys.path=.
The =sys.path= is initialized from the directory containing the input script (or the current directory if no script is given), [[https://docs.python.org/3.4/using/cmdline.html#envvar-PYTHONPATH][PYTHONPATH]], and then the installation-dependent default.
After initialization the =sys.path= variable can be modified, usually by putting the desired directory at the beginning of the search path.
-------
To speed up loading Python saves compiled versions of modules in the =__pycache__= directory with the name =module.version.pyc= where version is the Python version (e.g. =cpython-34=). 
The compiled modules are platform indepedent.
-------
Python comes with a library of *Standard Modules* described in the [[https://docs.python.org/3.4/library/index.html][Python Library Reference]].
Some modules are built into the interpreter, though which ones depends on the platform and the configuration.
The =sys= module has variables =sys.ps1= and =sys.ps2= that give the primary and secondary prompts, while =sys.path= is a list object which determines the interpreters search path.
-------
The =dir()= function returns a sorted list of names (variables, modules, functions, etc.) a module defines.
Without arguments it lists all names that are currently defined, but does not list names of built-in functions or variables.
To access these, import the =builtins= module then run =dir(builtins)=.
-------
*Packages* are a way of structuring Python's module namespace using "dotted module names", such as =A.B= for a submodule =B= in package =A=.
As an example, consider the design of a package to handle sound files and data.
The following examples shows a possible structure for the package (which is to include code to analyze different sound file formats, sound effects, filters, etc.).

#+BEGIN_EXAMPLE
sound/                          Top-level package
      __init__.py               Initialize the sound package
      formats/                  Subpackage for file format conversions
              __init__.py
              wavread.py
              wavwrite.py
              aiffread.py
              aiffwrite.py
              auread.py
              auwrite.py
              ...
      effects/                  Subpackage for sound effects
              __init__.py
              echo.py
              surround.py
              reverse.py
              ...
      filters/                  Subpackage for filters
              __init__.py
              equalizer.py
              vocoder.py
              karaoke.py
              ...
#+END_EXAMPLE

The =__init__.py= file are required so Python treats the directories as containing packages.
This file can be empty, or it can execute initialization code for the package or set the =__all__= variable.
Individual modules of the package can be imported like =import sound.effects.echo= (which then would need to be referenced by its full name).
If imported like =from sound.effects import echo= then an individual function would be referenced like =echo.echofilter=.
And finally, a statement like =from sound.effects.echo import echofilter= would load the submodule and bring the function in directly.
Note that for the syntax =from package import item= the =item= can be a submodule (or subpackage) of the package, or some other name defined in the package (like a function, class, or variable).
For the syntax =import item.subitem.subsubitem= requires that each item except for the last be a package, and the last item can be a module or a package but can't be a class, function, or variable defined in the previous item.

The packages that are imported when an =from module import *= can be defined in the =__init__.py= file with the =__all__= list variable.
The import statement will then import the submodules named in that variable and it is up to the module author to keep that up-to-date.
If =__all__= is not defined, the =import= statement above does /not/ import all submodules from the package, it only ensures that the names defined in the package are imported (and any initialization code in =__init__.py= is run).
Generally speaking, the =import *= approach is considered bad practice in production code.

For intra-package references, you can use either absolute imports, like =from sound.effects import echo=, or you can use relative imports using dot notation (similar to Linux filesystem referencing), like the following
#+BEGIN_SRC python
from . import echo
from .. import formats
from ..filters import equalizer
#+END_SRC

Packages also have the variable =__path__= which is initialized to be a list containing the name of the directory holding the package's =__init__.py=.

** Input and Output
Ways of outputing values:
1. Expression statements
2. The =print()= function
3. Using the =write()= method of file objects, where standard output can be referenced as =sys.stdout=

Two ways to format output:
1. String handling using slicing, concatenation, etc. to create layout
2. The =str.format()= method

Converting values to strings is handled by the =repr()= or =str()= functions.
The =str()= function is meant to return human-readable representations, while =repr()= is meant more for the interpreter.
Many values (numbers, lists, dictionaries) have the same representation using either function, while strings (for example) have distinct representations.
Here are two ways to print out a table of numbers, the first method using the =str.rjust()= method for right justification (also available are =str.ljust()= and =str.center()=), and the second using the =str.format()= method.

#+BEGIN_SRC python :results output :exports both
for x in range(1, 6):
    print(repr(x).rjust(2), repr(x*x).rjust(3), end=' ')
    # Note use of 'end' on previous line
    print(repr(x*x*x).rjust(4))
print('-----------')
for x in range(1, 6):
    print('{0:2d} {1:3d} {2:4d}'.format(x, x*x, x*x*x))
#+END_SRC

#+RESULTS:
#+begin_example
 1   1    1
 2   4    8
 3   9   27
 4  16   64
 5  25  125
-----------
 1   1    1
 2   4    8
 3   9   27
 4  16   64
 5  25  125
#+end_example

The =str.zfill()= method will pad a numeric string on the left with zeros.

Here are some examples of using the =str.format()= method, using both positional and keyword arguments.
#+BEGIN_SRC python :results output :exports both
print('We are the {} who say "{}!"'.format('knights', 'Ni'))
print('{0} and {1}'.format('spam', 'eggs'))
print('{1} and {0}'.format('spam', 'eggs'))
print('This {food} is {adjective}.'.format(
      food='spam', adjective='absolutely horrible'))
print('The story of {0}, {1}, and {other}.'.format('Bill', 'Manfred',
                                                       other='Georg'))
#+END_SRC

#+RESULTS:
: We are the knights who say "Ni!"
: spam and eggs
: eggs and spam
: This spam is absolutely horrible.
: The story of Bill, Manfred, and Georg.

='!a'= (apply =ascii()=), ='!s'= (apply =str()=) and ='!r'= (apply =repr()=) can be used to convert the value before it is formatted:
#+BEGIN_SRC python :results output :exports both
import math
print('The value of PI is approximately {!r}.'.format(math.pi))
#+END_SRC

#+RESULTS:
: The value of PI is approximately 3.141592653589793.

An optional =:= and format specifier can follow the field name for greater control over formatting.

#+BEGIN_SRC python :results output :exports both
import math
print('The value of PI is approximately {0:.3f}.'.format(math.pi))
#+END_SRC

#+RESULTS:
: The value of PI is approximately 3.142.

Passing an integer after the =:= will cause that field to be a minimum number of characters wide.
#+BEGIN_SRC python :results output :exports both
import math
print('The value of PI = ({0:.3f})'.format(math.pi))
print('The value of PI = ({0:8.3f})'.format(math.pi))
#+END_SRC

#+RESULTS:
: The value of PI = (3.142)
: The value of PI = (   3.142)

-------
In terms of *Reading and Writing Files*, =open()= returns a /file object/ most commonly used as =open(filename, mode)=.
The mode can be read (=​'r'​=, assumed if omitted), write (=​'w'​=), append (=​'a'​=), read and write (=​'r+'​=).
A (=​'b'​=) appended to the mode opens the file in binary mode (text mode is assumed by default).
The file object method =f.read()= will read the entire file's contents, and if run as =f.read(size)= then =size= bytes are read and returned.
=f.readline()= will read a single line leaving the newline character in the string.
You can loop over a file objecct which is memory efficient, fast, and leads to simple code (i.e. =for line in f:=).
Note that a simple way to read the file into a list is =list(f)= or =f.readlines()=.

=f.write(str)= writes the contents of string to the file, returning the number of characters written (to write non-string items, convert to string first).

=f.tell()= returns an integer giving the file object's current position in the file, and =f.seek()= can be used to change that position.
When you are done with a file call =f.close()= to close it and free system resources.

It is good practice to use the =with= keyword when dealing with file objects.
This has the advantage of automatically closing the file after the completion even if an exception is raised (e.g. =with open('workfile', 'r') as f:=).

-------
Rather than writing code to save complicated data, saving structured data with *JSON* ([[http://json.org/][Javascript Object Notation]]) is possible with the =json= module.
The module can take Python data hierarchies and convert them to string representations in a process called /serializing/.
Reconstructing the data is called /deserializing/.
For an object =x=, you can view its JSON string representation with =json.dumps(x)=, you can write it to a file object with =json.dump(x, f)=, and finally you can read it back with =x=json.load(f)=.
This simple serialization technique can handle lists and dictionaries (more complicated structures require more effort).
Note that *pickle* can serialize arbitrarily complex structures but creates a Python-specific result.

** Errors and Exceptions
There are two types of errors: /syntax errors/ and /exceptions/.
*** Syntax Errors
The parser prints out the offending line with an arrow pointing at the earliest point in the line where the error was detected.
#+BEGIN_EXAMPLE
  File "<stdin>", line 1
    while True print('Hello World')
                   ^
SyntaxError: invalid syntax
#+END_EXAMPLE
The error is caused by (or detected at) the token /preceding/ the arrow.
Above the error is detected at the =print= because a colon is missing before it.
*** Exceptions
Errors detected during execution are called /exceptions/ and it is possible to "handle" them in the code if detected (more later), though most exceptions are not handled in code.
Here's an example of an exception.
#+BEGIN_EXAMPLE
>>> 4 + spam*3
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'spam' is not defined
#+END_EXAMPLE

Exceptions come in different types (info on [[https://docs.python.org/3.4/library/exceptions.html#bltin-exceptions][built-in exceptions]] is linked), and the last line indicates what happened.
The preceding part of the message includes context about where the error happened, in the form of a stack traceback.

*** Handling Exceptions
The following shows an example of handling an exception usig the =try= and =except= statements.
#+BEGIN_SRC python :eval never
while True:
    try:
        x = int(input("Please enter a number: "))
        break
    except ValueError:
        print("Oops!  That was no valid number.  Try again...")
#+END_SRC
The =try= statement works as follows...
- First the =try= clause is executed
- If no exception occurs, the =except= clause is skipped and execution of the =try= clause is finished.
- If an exception occurs during the =try= clause, the rest of the clause is skipped and if its type matches the except clause is executed, then execution continues after the =try= statement
- If an exception occurs which does not match the =except= clause, it is passed on to outer =try= statements, and if not caught there then it is an /unhandled exception/ and execution stops
A =try= statement may have more than one except clause (but at most one handler will be executed).
An except clause may name several exceptions like =except (RuntimeError, TypeError, NameError):=.
The last except clause may omit the exception name to serve as a wildcard.
